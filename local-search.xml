<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>test</title>
    <link href="/blog/2023/06/12/test/"/>
    <url>/blog/2023/06/12/test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ajax</title>
    <link href="/blog/2023/06/09/ajax/"/>
    <url>/blog/2023/06/09/ajax/</url>
    
    <content type="html"><![CDATA[<p>AJAX 代表异步的 JavaScript 和 XML（Asynchronous JavaScript And XML）。简单点说，就是使用 <strong>XMLHttpRequest</strong> 对象与服务器通信。它可以使用 JSON、XML、HTML 和文本文件等格式发送和接收数据。AJAX 最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>首先新建一个XMLHttpRequest对象，设置了XMLHttpRequest 对象的 onreadystatechange 属性由哪一个 JavaScript 函数处理响应。这里是handler()。</p><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> httpRequest = <span class="hljs-keyword">new</span> XMLHttpRequest();httpRequest.onreadystatechange = handler;<span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 在这里处理服务器响应。</span>&#125;</code></pre></div><p>要注意的是，函数名后没有括号和参数，因为这是把一个引用赋值给了函数，而不是真正的调用了它。也可以这样写：</p><div class="code-wrapper"><pre><code class="hljs abnf">httpRequest.onreadystatechange <span class="hljs-operator">=</span> () <span class="hljs-operator">=</span>&gt; &#123;  // 在这里处理服务器响应。&#125;<span class="hljs-comment">;</span></code></pre></div><p>通过调用 HTTP 请求对象的 open() 和 send() 方法发送一个实际的请求</p><div class="code-wrapper"><pre><code class="hljs accesslog">httpRequest.open(<span class="hljs-string">&quot;<span class="hljs-keyword">GET</span>&quot;</span>, <span class="hljs-string">&quot;http://www.example.org/some.file&quot;</span>, true);httpRequest.send();</code></pre></div><p>第一个参数是 HTTP 请求方法——GET，POST，HEAD 以及服务器支持的其他方法,第二个参数是你要发送请求的 URL,第三个参数是可选的，用于设置请求是否是异步的,默认为true。<br>send() 方法的参数可以是任何你想发送给服务器的内容，使用send方法传递参数使用的是POST方法，需要设定Content-Type头信息。</p><div class="code-wrapper"><pre><code class="hljs pf">httpRequest.<span class="hljs-built_in">set</span>RequestHeader(  <span class="hljs-string">&quot;Content-Type&quot;</span>,  <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);</code></pre></div><p>在发送请求时，上文说到的 函数名handler负责处理响应。<br>可以先查看请求的状态httpRequest.readyState的值：<br>0（未初始化）或（请求还未初始化）<br>1（正在加载）或（已建立服务器链接）<br>2（已加载）或（请求已接收）<br>3（交互）或（正在处理请求）<br>4（完成）或（请求已完成并且响应已准备好）<br>再检查 HTTP 响应的响应状态码httpRequest.status的值。通过检查响应码 200 OK 判断 AJAX 调用有没有成功。<br>检查完请求状态和 HTTP 响应码后，就可以使用返回的数据了，有两个方法去访问这些数据：<br>httpRequest.responseText：以文本字符串的方式返回服务器响应。<br>httpRequest.responseXML：以 XMLDocument 对象的形式返回服务器响应。</p><h2 id="JQuery中ajax的使用"><a href="#JQuery中ajax的使用" class="headerlink" title="JQuery中ajax的使用"></a>JQuery中ajax的使用</h2><p>举个例子：</p><div class="code-wrapper"><pre><code class="hljs arcade">$.ajax(&#123;            <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;21json.php&#x27;</span>,            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;get&#x27;</span>,            <span class="hljs-comment">// 设置的是请求参数</span>            data: &#123;                <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,                <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>            &#125;,            <span class="hljs-comment">//也可以$ (“#id”).serialize()作为数据</span>            <span class="hljs-comment">//序列化表单中的数据和文本框等input select等的数据</span>            dataType: <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-comment">// 用于设置响应体的类型 注意 跟 data 参数没关系！！！</span>            success: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;                <span class="hljs-comment">// 一旦设置的 dataType 选项，就不再关心 服务端 响应的 Content-Type 了</span>                <span class="hljs-comment">// 客户端会主观认为服务端返回的就是 JSON 格式的字符串</span>                <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res);            &#125;            ,            <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;                <span class="hljs-comment">// 只有请求不正常（状态码不为200）才会执行</span>                <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>, res);            &#125;,            <span class="hljs-attr">complete</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;                <span class="hljs-comment">// 不管是成功还是失败都是完成，都会执行这个 complete 函数(一般功与失败都需要执行的操作写在这里)</span>                <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;complete&#x27;</span>, res);            &#125;        &#125;);</code></pre></div><p>beforeSend 在发送请求之前调用，并且传入一个XMLHttpRequest作为参数。<br>error 在请求出错时调用。传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象（如果有的话）<br>dataFilter 在请求成功之后调用。传入返回的数据以及”dataType”参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数。<br>success 当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。<br>complete 当请求完成之后调用这个函数，无论成功或失败。传入XMLHttpRequest对象，以及一个包含成功或错误代码的字符串。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker上跑一个Redis</title>
    <link href="/blog/2023/05/31/%E8%AE%A9Redis%E5%9C%A8Docker%E8%B7%91/"/>
    <url>/blog/2023/05/31/%E8%AE%A9Redis%E5%9C%A8Docker%E8%B7%91/</url>
    
    <content type="html"><![CDATA[<p>可以用docker pull redis命令下载最新版本的Redis镜像，也可以用“docker pull redis:标签”命令下载指定版本的Redis，如果不指定，就会用默认的标签latest去下载最新版本的Redis镜像。</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull redis</span></code></pre></div><p>run一个redis容器</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -itd --name myredis -p <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> redis:latest</code></pre></div><p>这里的-it表示在终端交互式操作，d表示在后台运行；通过–name指定该容器的名字；通过-p参数指定容器的6379端口映射到宿主机（即运行Docker的机器）6379端口，这样在容器外部就能以宿主机ip:6379的方式访问Redis服务；最后的redis:latest参数指定根据该镜像启动容器。<br>可以使用下面命令查看容器启动时的日志</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker logs myredis</span></code></pre></div><p><img src="https://img1.imgtp.com/2023/06/02/3dQMrwip.png" alt="日志图片"><br>可以通过如下的exec命令进入Redis容器</p><div class="code-wrapper"><pre><code class="hljs awk">docker exec -it myredis <span class="hljs-regexp">/bin/</span>bash</code></pre></div><p>docker exec表示在运行的容器中执行命令，其中myredis参数表示在哪个容器(容器name)里执行命令。</p><p>再使用命令redis-cli创建一个连接到redis服务器的客户端，客户端能对服务器发送命令请求如 set val 1、get val。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/blog/2023/05/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2023/05/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><img src="https://img1.imgtp.com/2023/05/30/PFfKwPj7.png" alt="单例模式"></p><p>太阳系里只有一个太阳，太阳东升西落，循环往复，不多不少仅此一例。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>即在初始阶段就主动进行实例化，并时刻保持一种渴求状态，无论此单例是否有人使用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> &#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sun</span> <span class="hljs-variable">sun</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sun</span>();<span class="hljs-comment">//自有永有的太阳单例</span><span class="hljs-keyword">private</span> <span class="hljs-title function_">Sun</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//构造方法私有化</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sun <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//阳光普照，方法公开化</span><span class="hljs-keyword">return</span> sun;&#125;</code></pre></div><p>在第3行将<strong>太阳类Sun的构造方法设为private，使其私有化</strong>，如此一来太阳类就被完全封闭了起来，实例化工作完全归属于内部事务，任何外部类都无权干预。既然如此，那么我们就让它自己创建自己。</p><p>代码第2行中“private”关键字确保太阳实例的私有性、不可见性和不可访问性；而“static”关键字确保太阳的静态性，将太阳<strong>放入内存里的静态区，在类加载的时候就初始化了</strong>，它与类同在，也就是说它是与类同时期且早于内存堆中的对象实例化的，该实例在内存中永生，内存垃圾收集器也不会对其进行回收；“final”关键字则确保这个太阳是常量、恒量，它是一颗终极的恒星，<strong>引用一旦被赋值就不能再修改</strong>；最后，“new”关键字初始化太阳类的静态实例，并赋予静态常量sun。</p><p>对外部来说只要调用Sun.getInstance()就可以得到太阳对象了，并且不管谁得到，或是得到几次，得到的都是同一个太阳实例，这样就确保了整个太阳系中恒星太阳的唯一合法性，他人无法伪造。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>让太阳一开始就准备就绪，随时供应免费日光。然而，如果始终没人获取日光，那岂不是白造了太阳，一块内存区域被白白地浪费了？这正类似于商家货品滞销的情况，货架上堆放着商品却没人买，白白浪费空间。因此，商家为了降低风险，规定有些商品必须提前预订，这就是“懒汉式”。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Sun sun;<span class="hljs-comment">//这里不进行实例化</span> <span class="hljs-keyword">private</span> <span class="hljs-title function_">Sun</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//构造方法私有化</span>&#125;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sun <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">if</span> (sun == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//如果无日才造日</span> sun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sun</span>(); &#125; <span class="hljs-keyword">return</span> sun; &#125; &#125;</code></pre></div><p>一开始不对Sun进行实例化并去掉了Final修饰符，第一次调用getInstance()再进行实例化，没有被调用则不用实例化，缺点是第一次调用时花费时间长些，要进行实例化sun。</p><p>这样的程序逻辑看似没问题，但其实在多线程模式下是有缺陷的。试想如果是并发请求的话，程序第6行的判空逻辑就会同时成立，这样就会多次实例化太阳，并且<strong>对sun进行多次赋值（覆盖）操作，这违背了单例的理念</strong>。把请求方法加上synchronized让其同步，如此一来，<strong>某线程调用前必须获取同步锁，调用完后会释放锁给其他线程用，也就是给请求排队，一个接一个按顺序来</strong>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> synchronizsed Sun <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">if</span> (sun == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//如果无日才造日</span>sun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sun</span>();&#125;<span class="hljs-keyword">return</span> sun;&#125;</code></pre></div><p><strong>线程还没进入方法内部便直接加锁排队，会造成线程阻塞，资源与时间被白白浪费。</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> &#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Sun sun; <span class="hljs-keyword">private</span> <span class="hljs-title function_">Sun</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//构造方法私有化</span> &#125; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sun <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">if</span> (sun == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//没有太阳进行排队，让排头兵造，有太阳则阳光普照</span>   <span class="hljs-keyword">synchronized</span>(Sun.class)&#123;<span class="hljs-comment">//排队</span>     <span class="hljs-keyword">if</span> (sun == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//排头兵发现没有太阳，排头兵造了太阳，此时有了太阳，后面的队伍则也不需要造日</span>        sun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sun</span>();      &#125;    &#125;  &#125; <span class="hljs-keyword">return</span> sun; <span class="hljs-comment">//阳光普照</span> &#125; &#125;</code></pre></div><p>关键字volatile对静态变量的修饰则能<strong>保证变量值在各线程访问时的同步性、唯一性。</strong><br>第7行又加上了同步块以防止多个线程同时进入，一共用了2个嵌套的判空逻辑，这就是懒加载模式的“双检锁”：<strong>外层放宽入口</strong>，保证线程并发的高效性；<strong>内层加锁同步</strong>，保证实例化的单次运行。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>相比“懒汉式”，其实在大多数情况下通常会更多地使用“饿汉式”，原因在于这个单例迟早是要被实例化占用内存的，延迟懒加载的意义并不大，加锁解锁反而是一种资源浪费，同步更是会降低CPU的利用率，使用不当的话反而会带来不必要的风险。越简单的包容性越强，而越复杂的反而越容易出错。</p><h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><img src="https://img1.imgtp.com/2023/05/31/jWzZg2AD.png" alt="策略模式"></p><p>策略模式强调的是行为的灵活切换，比如一个类的多个方法有着类似的行为接口，可以将它们抽离出来作为一系列策略类，在运行时灵活对接，变更其算法策略，以适应不同的场景。<br>下面定义一个统一的算法策略接口：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Strategy</span> &#123;<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<span class="hljs-comment">//操作数a，被操作数b</span>&#125;</code></pre></div><p>接着分别定义加法策略、减法策略对应的实现类:</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Addition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<span class="hljs-comment">//加数与被加数作为参数</span><span class="hljs-keyword">return</span> a + b;<span class="hljs-comment">//做加法运算并返回结果</span>&#125; &#125; <span class="hljs-comment">//减法省略······</span></code></pre></div><p>将算法策略注入客户端，使用这一系列算法策略。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<span class="hljs-comment">//包含策略接口的系统环境，对外提供更换策略实现的方法setStrategy()以及执行策略的方法</span> <span class="hljs-keyword">private</span> Strategy strategy;<span class="hljs-comment">//算法策略接口</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStrategy</span><span class="hljs-params">(Strategy strategy)</span> &#123;<span class="hljs-comment">//注入算法策略</span> <span class="hljs-built_in">this</span>.strategy = strategy; &#125; <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<span class="hljs-comment">//其本身并不关心执行的是哪种策略实现。</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.strategy.calculate(a, b);<span class="hljs-comment">//返回具体策略的运算结果</span>&#125; &#125;</code></pre></div><p>在setStrategy()中注入的策略，将在getResult()中被使用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-type">Context</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<span class="hljs-comment">//实例化</span> c.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Addition</span>());<span class="hljs-comment">//注入加法策略实现</span> System.out.println(c.getResult(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<span class="hljs-comment">//输出结果为2</span> c.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Subtraction</span>());<span class="hljs-comment">//再注入减法策略实现</span> System.out.println(c.getResult(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<span class="hljs-comment">// 输出结果为0</span> &#125;</code></pre></div><p>只需注入相应的算法策略即可得到结果。此外，今后若要进行功能扩展，只需要新增兼容策略接口的算法策略类（如乘法、除法等）。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>策略模式让策略与系统环境彻底解耦，通过对算法策略的抽象、拆分，再拼装使系统行为的可塑性得到了增强。策略接口的引入也让各种策略实现彻底解放，最终实现算法分立，即插即用。</p><p>策略模式的运用能让系统的应变能力得到提升，适应随时变化的需求。接口的巧妙运用让一系列的策略可以脱离系统而单独存在，使系统拥有更灵活、更强大的“可插拔”扩展功能。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p><img src="https://img1.imgtp.com/2023/05/31/JMsKx7a6.png" alt="命令模式"><br>命令是一个对象向另一个或多个对象发送的指令信息。命令的发送方负责下达指令，接收方则根据命令触发相应的行为，命令模式能够<strong>将指令信息封装成一个对象</strong>，并将此对象作为参数发送给接收方去行，以使命令的请求方与执行方解耦，双方只通过传递各种命令对象来完成任务。</p><p>从命令执行方（Recelver）开始代码实战。灯泡类一定有这样2个行为：通电灯亮，断电灯灭。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bulb</span> &#123;<span class="hljs-comment">//命令执行方</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;灯亮。&quot;</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;灯灭。&quot;</span>);&#125; &#125;</code></pre></div><p>定义一个命令接口，以确立命令的执行规范。</p><div class="code-wrapper"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<span class="hljs-comment">//命令接口</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<span class="hljs-comment">//执行命令</span>&#125;</code></pre></div><p>实现“开命令”（OnCommand）与“关命令”（OffCommand）两个实现类。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OnCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<span class="hljs-comment">//开灯命令实现</span> <span class="hljs-keyword">private</span> Bulb bulb; <span class="hljs-keyword">public</span> <span class="hljs-title function_">OnCommand</span><span class="hljs-params">(Bulb bulb)</span> &#123; <span class="hljs-built_in">this</span>.bulb = bulb; &#125; <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123; bulb.on();<span class="hljs-comment">// 执行开灯操作</span> &#125;&#125;<span class="hljs-comment">//关灯省略······</span></code></pre></div><p>为灯泡接上一个开关,作为命令请求方(Invoker)，开关用来根据输入的命令控制电源的接通与切断。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Switcher</span> &#123; <span class="hljs-keyword">private</span> Command command;<span class="hljs-comment">// 设置命令</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command command)</span> &#123; <span class="hljs-built_in">this</span>.command = command;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">button</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 执行命令</span> command.execute(); &#125; &#125;</code></pre></div><p>主程序代码：</p><div class="code-wrapper"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-type">Switcher</span> <span class="hljs-variable">switcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Switcher</span>();<span class="hljs-comment">//命令请求方</span><span class="hljs-type">Bulb</span> <span class="hljs-variable">bulb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bulb</span>();<span class="hljs-comment">//命令执行方</span> <span class="hljs-type">Command</span> <span class="hljs-variable">onCommand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OnCommand</span>(bulb);<span class="hljs-comment">//开命令</span>  <span class="hljs-type">Command</span> <span class="hljs-variable">offCommand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OffCommand</span>(bulb);<span class="hljs-comment">//关命令</span> switcher.setCommand(onCommand);<span class="hljs-comment">//绑定开命令</span> switcher.button();<span class="hljs-comment">//执行开命令的具体操作</span> switcher.setCommand(offCommand);<span class="hljs-comment">//绑定关命令</span> switcher.button();<span class="hljs-comment">//执行关命令的具体操作</span> &#125; &#125;</code></pre></div><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>命令模式能使我们在不改变任何现有系统代码的情况下，实现命令功能的无限扩展。命令模式巧妙地利用了命令接口将命令请求方与命令执行方隔离开来，使发号施令者与任务执行者解耦，甚至意识不到对方接口的存在而全靠命令的上传下达。</p><p>任何模式都有优缺点。命令模式可能会导致系统中命令类定义泛滥的问题。命令模式其实与策略模式非常类似，只不过前者较后者多了一层封装，命令接口的统一确立，使系统可以忽略命令执行方接口的多样性与复杂性，将接口对接与业务逻辑交给具体的命令去实现，并且实现命令的无限扩展。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p><img src="https://img1.imgtp.com/2023/06/02/xhv6834h.jpg" alt="观察者模式"></p><p>观察者往往眼观六路，耳听八方，随时监控着被观察对象的一举一动。作为主动方的观察者对象必须与被观察对象建立依赖关系，以获得其最新动态。</p><p>观察者模式可以有任意多个观察者对象同时监听某一个对象。监听某个对象的叫观察者（Observer）。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>; <span class="hljs-comment">//更新方法</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserverImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//更新方法</span>    <span class="hljs-comment">//省略</span>    &#125;&#125;</code></pre></div><p>被监听的对象叫被观察者（Subject） 。被观察者对象在内容或状态发生改变时，会通知所有观察者，使它们能自动更新自己的信息。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-keyword">private</span> List&lt;Observer&gt; obsList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&lt;Observer&gt;();    <span class="hljs-comment">//定义一个观察者数组</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(Oberver obs)</span>       <span class="hljs-comment">//增加一个观察者</span>    &#123;<span class="hljs-built_in">this</span>.obsList.add(obs); &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delObserver</span><span class="hljs-params">(Observer obs)</span><span class="hljs-comment">//删除观察者</span>    &#123;<span class="hljs-built_in">this</span>.obsList.remove(obs);&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">//通知所有观察者</span>    <span class="hljs-keyword">for</span> (Observer obs:<span class="hljs-built_in">this</span>.obsList)&#123;              obs.update();         &#125;     &#125;&#125;</code></pre></div><p>被观察者的具体实现：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubjectImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">//具体的业务</span>        <span class="hljs-comment">/*</span><span class="hljs-comment">        do something</span><span class="hljs-comment">       */</span>       <span class="hljs-built_in">super</span>.notifyObservers();<span class="hljs-comment">//执行obs.update();通知观察者们</span>     &#125;&#125;</code></pre></div><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>观察者模式被大量应用于具有一对多关系对象结构的场景，它支持多个观察者订阅一个目标主题。一旦目标主题的状态发生变化，目标对象便主动进行广播，即刻对所有订阅者（观察者）发布全员消息通知。<br>基于这种一对多的关系网，观察者模式以多态化（泛型化）的方式弱化了目标主题与观察者之间强耦合的依赖关系，标准化它们的消息交互接口，使目标主题（单方）的任何状态更新都能被即刻通过广播的形式通知观察者们（多方）。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装与使用</title>
    <link href="/blog/2023/05/19/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2023/05/19/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h1><h2 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h2><p>列出系统中已安装的docker包：</p><div class="code-wrapper"><pre><code class="hljs 1c">yum list installed <span class="hljs-string">| grep docker</span></code></pre></div><p>卸载已安装的docker包：</p><div class="code-wrapper"><pre><code class="hljs livescript">sudo yum remove docker <span class="hljs-string">\</span>                  docker-client <span class="hljs-string">\</span>                  docker-client-latest <span class="hljs-string">\</span>                  docker-common <span class="hljs-string">\</span>                  docker-latest <span class="hljs-string">\</span>                  docker-latest-logrotate <span class="hljs-string">\</span>                  docker-logrotate <span class="hljs-string">\</span>                  docker-engine</code></pre></div><p>如果系统中没有 Docker，则直接进入下一步。<br>安装软件包（提供实用程序）</p><div class="code-wrapper"><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> -y yum-utils</code></pre></div><p>添加 Docker 的 yum 源：</p><div class="code-wrapper"><pre><code class="hljs awk">sudo yum-config-manager --add-repo https:<span class="hljs-regexp">//mi</span>rrors.cloud.tencent.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/centos/</span>docker-ce.repo</code></pre></div><p>yum 安装 Docker：</p><div class="code-wrapper"><pre><code class="hljs stata">sudo yum install docker-ce docker-ce-<span class="hljs-keyword">cli</span> containerd.io docker-buildx-<span class="hljs-keyword">plugin</span> docker-compose-<span class="hljs-keyword">plugin</span></code></pre></div><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>卸载旧版本<br>在安装 Docker 引擎之前，您必须首先确保任何 将卸载冲突的软件包。<br>发行版维护者在 容易。您必须先卸载这些软件包，然后才能安装官方 Docker 引擎的版本。<br>要卸载的非官方软件包是：<br>docker.io<br>docker-compose<br>docker-doc<br>podman-docker<br>此外，Docker引擎依赖于和.码头工人引擎 将这些依赖项捆绑为一个捆绑包：。如果你有 安装了或以前，卸载它们以避免 与 Docker 引擎捆绑的版本冲突</p><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> pkg <span class="hljs-keyword">in</span> docker.io docker-doc docker-compose podman-docker containerd runc; <span class="hljs-keyword">do</span> sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> <span class="hljs-variable">$pkg</span>; done</code></pre></div><p>更新软件包索引并安装软件包以允许使用 基于 HTTPS 的存储库：</p><div class="code-wrapper"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> updatesudo apt-<span class="hljs-built_in">get</span> install ca-certificates curl gnupg</code></pre></div><p>添加 Docker 的官方 GPG 密钥：</p><div class="code-wrapper"><pre><code class="hljs awk">sudo install -m <span class="hljs-number">0755</span> -d <span class="hljs-regexp">/etc/</span>apt/keyringscurl -fsSL https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/u</span>buntu<span class="hljs-regexp">/gpg | sudo gpg --dearmor -o /</span>etc<span class="hljs-regexp">/apt/</span>keyrings/docker.gpgsudo chmod a+r <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/keyrings/</span>docker.gpg</code></pre></div><p>使用以下命令设置存储库：</p><div class="code-wrapper"><pre><code class="hljs gradle">echo \  <span class="hljs-string">&quot;deb [arch=&quot;</span>$(dpkg --<span class="hljs-keyword">print</span>-architecture)<span class="hljs-string">&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span><span class="hljs-string">  &quot;</span>$(. <span class="hljs-regexp">/etc/</span>os-release &amp;&amp; echo <span class="hljs-string">&quot;$VERSION_CODENAME&quot;</span>)<span class="hljs-string">&quot; stable&quot;</span> | \  sudo tee <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list.d/</span>docker.list &gt; <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span></code></pre></div><p>安装最新版本，请运行：</p><div class="code-wrapper"><pre><code class="hljs stata">sudo apt-get install docker-ce docker-ce-<span class="hljs-keyword">cli</span> containerd.io docker-buildx-<span class="hljs-keyword">plugin</span> docker-compose-<span class="hljs-keyword">plugin</span></code></pre></div><h2 id="验证-Docker-版本以确认安装成功"><a href="#验证-Docker-版本以确认安装成功" class="headerlink" title="验证 Docker 版本以确认安装成功"></a>验证 Docker 版本以确认安装成功</h2><div class="code-wrapper"><pre><code class="hljs applescript">docker <span class="hljs-built_in">version</span></code></pre></div><h2 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h2><p>执行以下命令启动 Docker：</p><div class="code-wrapper"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker</code></pre></div><p>然后将 Docker 设置为开机启动：</p><div class="code-wrapper"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> docker</code></pre></div><p>查看 Docker 运行状态：</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">service docker status</span></code></pre></div><p>如图所示，Docker 正在运行：</p><p><img src="https://img1.imgtp.com/2023/05/29/PByA2O8s.png" alt="运行状态图"></p><h2 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h2><div class="code-wrapper"><pre><code class="hljs awk">mkdir -p <span class="hljs-regexp">/etc/</span>docker</code></pre></div><p>配置 Docker 镜像加速源：</p><div class="code-wrapper"><pre><code class="hljs awk">tee <span class="hljs-regexp">/etc/</span>docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span>&#123;  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://mirror.ccs.tencentyun.com&quot;</span>]&#125;EOF</code></pre></div><p>重启守护进程并重启 Docker：</p><div class="code-wrapper"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl daemon-reload &amp;&amp; <span class="hljs-params">system</span>ctl restart docker</code></pre></div><p>重启完成后，镜像加速即配置成功。</p><h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="运行第一个容器"><a href="#运行第一个容器" class="headerlink" title="运行第一个容器"></a>运行第一个容器</h2><p>用 docker run 命令可以直接拉取镜像并运行一个容器，例如：</p><div class="code-wrapper"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> <span class="hljs-attribute">--name</span>=hello hello-world</code></pre></div><p>这行命令会直接拉取 hello-world 镜像，然后运行一个 hello 容器，可以通过以下命令查看该容器的进程：</p><div class="code-wrapper"><pre><code class="hljs css">docker ps -<span class="hljs-selector-tag">a</span></code></pre></div><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>镜像拉取成功后，根据镜像创建容器：</p><div class="code-wrapper"><pre><code class="hljs awk">docker create --name=calibre-web -p <span class="hljs-number">80</span>:<span class="hljs-number">8083</span> -v <span class="hljs-regexp">/data/</span>calibre-web<span class="hljs-regexp">/library:/</span>library -e WEBLANGUAGE=zh_CN johngong/calibre-web</code></pre></div><p>其中：<br>•docker create 是创建容器的命令<br>•–name&#x3D;calibre-web 表示创建的容器的名称<br>•-p 80:8083 表示该容器将 80 端口映射到 8083 端口<br>•-v &#x2F;data&#x2F;calibre-web&#x2F;librery:&#x2F;libray 表示该容器将 &#x2F;data&#x2F;calibre-web&#x2F;library 目录映射为 &#x2F;library 目录<br>•-e WEBLANGUAGE&#x3D;zh_CN 表示该容器定义了一个变量，变量名是 WEBLANGUAGE，变量值是 zh_CN<br>•johngong&#x2F;calibre-web 是容器的镜像，这里也就是我们前面拉取的镜像<br>与 docker run 不同的是，docker create 创建出来的容器不会直接运行。</p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>使用以下命令启动刚才创建好的容器：</p><div class="code-wrapper"><pre><code class="hljs crmsh">docker <span class="hljs-literal">start</span> calibre-web</code></pre></div><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><p>要停止正在运行的容器有两种方法。一种是 docker stop，例如：</p><div class="code-wrapper"><pre><code class="hljs arduino">docker stop calibre-web</code></pre></div><p>另一种方法是 docker kill，例如：</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> calibre-web</code></pre></div><p>这两种方法的区别在于，docker stop 会给时间让容器保存最后的运行状态，而 docker kill 则会直接关闭容器。</p><h2 id="删除终止状态的容器"><a href="#删除终止状态的容器" class="headerlink" title="删除终止状态的容器"></a>删除终止状态的容器</h2><p>使用 docker rm 命令可以删除指定的容器，例如：</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> hello</code></pre></div><h2 id="删除运行状态的容器"><a href="#删除运行状态的容器" class="headerlink" title="删除运行状态的容器"></a>删除运行状态的容器</h2><p>我们先重新运行 calibre-web 容器： </p><div class="code-wrapper"><pre><code class="hljs crmsh">docker <span class="hljs-literal">start</span> calibre-web</code></pre></div><p>这时候我们用 docker rm 删除该容器：</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> calibre-web</code></pre></div><p>命令行会报错,要删除运行状态的容器，需要带上 -f 选项：</p><div class="code-wrapper"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> calibre<span class="hljs-literal">-web</span></code></pre></div><p>正在运行的 calibre-web 会被强制停止并删除。</p><h2 id="删除指定镜像"><a href="#删除指定镜像" class="headerlink" title="删除指定镜像"></a>删除指定镜像</h2><p>使用 docker rmi 命令可以删除指定的镜像，例如：</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker rmi hello-world</span></code></pre></div><h1 id="制作自己的镜像"><a href="#制作自己的镜像" class="headerlink" title="制作自己的镜像"></a>制作自己的镜像</h1><h2 id="编写-Dockerfile文件"><a href="#编写-Dockerfile文件" class="headerlink" title="编写 Dockerfile文件"></a>编写 Dockerfile文件</h2><div class="code-wrapper"><pre><code class="hljs dockerfile">$ <span class="hljs-keyword">FROM</span> node:<span class="hljs-number">11</span><span class="hljs-keyword">MAINTAINER</span> easydoc.net<span class="hljs-comment"># 复制代码</span><span class="hljs-keyword">ADD</span><span class="language-bash"> . /app</span><span class="hljs-comment"># 设置容器启动后的默认运行目录</span><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><span class="hljs-comment"># 运行命令，安装依赖</span><span class="hljs-comment"># RUN 命令可以有多个，但是可以用 &amp;&amp; 连接多个命令来减少层级。</span><span class="hljs-comment"># 例如 RUN npm install &amp;&amp; cd /app &amp;&amp; mkdir logs</span><span class="hljs-keyword">RUN</span><span class="language-bash"> npm install --registry=https://registry.npm.taobao.org</span><span class="hljs-comment"># CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。</span><span class="hljs-comment"># 如果还需要运行其他命令可以用 &amp;&amp; 连接，也可以写成一个shell脚本去执行。</span><span class="hljs-comment"># 例如 CMD cd /app &amp;&amp; ./start.sh</span><span class="hljs-keyword">CMD</span><span class="language-bash"> node app.js</span></code></pre></div><h2 id="Build-为镜像和运行"><a href="#Build-为镜像和运行" class="headerlink" title="Build 为镜像和运行"></a>Build 为镜像和运行</h2><p>编译 </p><div class="code-wrapper"><pre><code class="hljs mipsasm">$ docker <span class="hljs-keyword">build </span>-t test:<span class="hljs-built_in">v1</span> <span class="hljs-comment">#-t 设置镜像名字和版本号</span></code></pre></div><p>命令参考：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a><br>运行容器</p><div class="code-wrapper"><pre><code class="hljs stata">$ docker <span class="hljs-keyword">run</span> -p 8080:8080 --name <span class="hljs-keyword">test</span>-hello <span class="hljs-keyword">test</span>:v1</code></pre></div><p>-p 映射容器内端口到宿主机<br>–name 容器名字<br>-d 后台运行<br>命令参考文档：<a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></p><h2 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h2><div class="code-wrapper"><pre><code class="hljs bash">$ docker ps <span class="hljs-comment">#查看当前运行中的容器</span>docker images <span class="hljs-comment">#查看镜像列表</span>docker <span class="hljs-built_in">rm</span> container-id <span class="hljs-comment">#删除指定 id 的容器</span>docker stop/start container-id <span class="hljs-comment">#停止/启动指定 id 的容器</span>docker rmi image-id <span class="hljs-comment">#删除指定 id 的镜像</span>docker volume <span class="hljs-built_in">ls</span> <span class="hljs-comment">#查看 volume 列表</span>docker network <span class="hljs-built_in">ls</span> <span class="hljs-comment">#查看网络列表</span>docker <span class="hljs-built_in">exec</span> -it name /bin/bash <span class="hljs-comment">#进入容器name</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
