<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>文件权限及属性</title>
    <link href="/blog/2023/06/28/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%8F%8A%E5%B1%9E%E6%80%A7/"/>
    <url>/blog/2023/06/28/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%8F%8A%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“r”表示能够读取文件的实际内容；“w”表示能够编辑、新增、修改、删除文件的实际内容；“x”则表示能够运行一个脚本程序。对于目录文件来说，“r”表示能够读取目录内的文件列表；<strong>“w”表示能够在目录内新增、删除、重命名文件或目录</strong>；而“x”则表示能够进入该目录。</p><p><img src="https://img1.imgtp.com/2023/07/10/k8JI8741.png"></p><p>文件权限的数字表示法基于字符（rwx）的权限计算而来，其目的是简化权限的表示方式。例如，若某个文件的权限为7，则代表可读、可写、可执行（4+2+1）；若权限为6，则代表可读、可写（4+2）。我们来看一个例子。现在有这样一个文件，其所有者拥有可读、可写、可执行的权限，其文件所属组拥有可读、可写的权限；其他人只有可读的权限。那么，这个文件的权限就是rwxrw-r–，数字法表示即为764。</p><p><img src="https://img1.imgtp.com/2023/07/10/J37GO6KI.png"></p><h2 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h2><p><strong>SUID</strong></p><p>SUID是一种对二进制程序进行设置的特殊权限，能够让二进制程序的执行者（普通用户）临时拥有所有者的权限（仅对拥有执行权限的二进制程序有效）。</p><p>所有用户都可以执行passwd命令来修改自己的用户密码，而用户密码保存在&#x2F;etc&#x2F;shadow文件中（文件所有者为root）。仔细查看这个文件就会发现它的默认权限是000，也就是说除了root管理员以外，所有用户都没有查看或编辑该文件的权限（root超级管理员可以对任何文件进行修改）。但是，在使用passwd命令时如果加上SUID特殊权限位，就可让普通用户临时获得程序所有者的身份，把变更的密码信息写入到shadow文件中。</p><p>SUID权限使用s表示，增加权限u+s，移除权限u-s；如果原先权限位上没有x执行权限，那么被赋予特殊权限后将变成大写的S。用数字形式表示，0表示去除SUID权限，4表示添加SUID权限，而且<strong>是在原权限的数字表达形式开头加0或4</strong>，如：0755移除SIUD权限，4755添加SUID权限。</p><p><strong>SGID</strong></p><p>SGID特殊权限有两种应用场景：当对二进制程序进行设置时，能够让执行者临时获取文件所属组的权限；当对目录进行设置时，则是让目录内新创建的文件自动继承该目录原有用户组的名称。</p><p>平时需要查看系统的进程状态，为了能够获取进程的状态信息，可在用于查看系统进程状态的ps命令文件上增加SGID特殊权限位。这样一来，由于ps命令被增加了SGID特殊权限位，所以当用户执行该命令时，也就临时获取到了system用户组的权限，从而顺利地读取到了设备文件。</p><p>SGID权限使用s表示，增加权限g+s，移除权限g-s；如果原先权限位上没有x执行权限，那么被赋予特殊权限后将变成大写的S。用数字形式表示，0表示去除SGID权限，2表示添加SGID权限，而且<strong>是在原权限的数字表达形式开头加0或2</strong>，如：0755移除SGID权限，2755添加SGID权限。</p><p><strong>SBIT</strong></p><p>SBIT特殊权限位可确保用户只能删除自己的文件，而不能删除其他用户的文件。换句话说，当对某个目录设置了SBIT粘滞位权限后，那么该目录中的文件就只能被其所有者删除了。当目录被设置SBIT特殊权限位后，文件的其他用户权限部分的x执行权限就会被替换成t或者T—原本有x执行权限则会写成t，原本没有x执行权限则会被写成T。</p><p>SBIT权限使用t表示，增加权限o+t，移除权限o-t；如果原先权限位上没有x执行权限，那么被赋予特殊权限后将变成大写的T。用数字形式表示，0表示去除SBIT权限，1表示添加SBIT权限，而且<strong>是在原权限的数字表达形式开头加0或1</strong>，如：0755移除SBIT权限，1755添加SBIT权限。</p><p>示例</p><p><img src="https://img1.imgtp.com/2023/07/10/stebJNgL.jpg"></p><p><img src="https://img1.imgtp.com/2023/07/10/YeupfEYP.jpg"></p><h2 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h2><p>ACL也就是（Access Control List）<br>chmod命令可以把文件权限分为u,g,o三个组，setfacl可以对指定的用户或用户组设置文件或目录的操作权限，更加精准地派发权限。getfacl 命令用于查看文件或目录当前设定的 ACL 权限信息。<br>setfacl 参数<br>  -m：添加acl参数<br>  -x：删除acl参数<br>  -b：删除全部的acl参数<br>  -k：删除默认的acl参数<br>  -R：递归设置acl，包括子目录<br>  -d：设置默认acl （对文件夹设置后所有新建的子文件都会 ACL 权限）</p><p>示例</p><p>将xinibb用户对aclacl文件的权限修改成rwx</p><p>删除xinibb对aclacl文件的权限命令： setfacl -x u:xinibb:rwx aclacl</p><p><img src="https://img1.imgtp.com/2023/07/11/8vCsMLA3.png"></p><p>备份和恢复</p><p><img src="https://img1.imgtp.com/2023/07/11/WEYYXTfe.png"></p><h2 id="文件的隐藏属性"><a href="#文件的隐藏属性" class="headerlink" title="文件的隐藏属性"></a>文件的隐藏属性</h2><p><strong>chattr</strong>命令用于设置文件的隐藏权限，英文全称为change attributes，语法格式为“chattr [参数] 文件名称”。</p><p>如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把某个隐藏功能移出文件，则需要追加“-参数”。</p><table><thead><tr><th align="left">参数</th><th>作用</th></tr></thead><tbody><tr><td align="left">i</td><td>无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件</td></tr><tr><td align="left">a</td><td>仅允许补充（追加）内容，无法覆盖&#x2F;删除内容</td></tr><tr><td align="left">A</td><td>不再修改这个文件或目录的最后访问时间</td></tr><tr><td align="left">s</td><td>彻底从硬盘中删除，不可恢复</td></tr><tr><td align="left">S</td><td>文件内容在变更后立即同步到硬盘</td></tr><tr><td align="left">b</td><td>不再修改文件或目录的存取时间</td></tr><tr><td align="left">d</td><td>使用dump命令备份时忽略本文件&#x2F;目录v</td></tr><tr><td align="left">D</td><td>检查压缩文件中的错误</td></tr><tr><td align="left">c</td><td>默认将文件或目录进行压缩</td></tr><tr><td align="left">u</td><td>当删除该文件后依然保留其在硬盘中的数据，方便日后恢复</td></tr></tbody></table><p><strong>lsattr</strong>命令用于查看文件的隐藏权限，英文全称为“list attributes”，语法格式为“lsattr [参数] 文件名称”。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell</title>
    <link href="/blog/2023/06/21/Shell/"/>
    <url>/blog/2023/06/21/Shell/</url>
    
    <content type="html"><![CDATA[<p>Shell 是一个应用程序，它的一端连接着 Linux 内核，另一端连接着用户。Shell 是用户和 Linux 系统沟通的桥梁，我们都是通过 Shell 来管理 Linux 系统。<br>我们可以直接使用 Shell，也可以输入用户名和密码后再使用 Shell；第一种叫做非登录式，第二种叫做登录式。<br>我们可以在 Shell 中一个个地输入命令并及时查看它们的输出结果，整个过程都在跟 Shell 不停地互动，这叫做交互式。我们也可以运行一个 Shell 脚本文件，让所有命令批量化、一次性地执行，这叫做非交互式。<br>总起来说，Shell 一共有四种运行方式：<br>1.交互式的登录 Shell<br>2.交互式的非登录 Shell；<br>3.非交互式的登录 Shell；<br>4.非交互式的非登录 Shell。</p><h2 id="判断-Shell-是否是交互式"><a href="#判断-Shell-是否是交互式" class="headerlink" title="判断 Shell 是否是交互式"></a>判断 Shell 是否是交互式</h2><p> 方法一：查看变量-的值，如果值中包含了字母i，则表示交互式（interactive）。</p><p>终端下输出<code>-</code>的值</p><p><img src="https://img1.imgtp.com/2023/07/07/kylMoCU9.png"></p><p>在 Shell 脚本文件中输出<code>-</code>的值</p><p><img src="https://img1.imgtp.com/2023/07/07/fs9wglmX.png"></p><p>方法二： 查看变量<code>PS1</code>的值，如果非空，则为交互式，否则为非交互式，因为非交互式会清空该变量。</p><p>终端下输出 PS1 的值</p><p><img src="https://img1.imgtp.com/2023/07/07/Vi9vTYdY.png"></p><p>在 Shell 脚本文件中输出 PS1 的值</p><p><img src="https://img1.imgtp.com/2023/07/07/Y8BoNgYV.png"></p><p>执行.&#x2F;test.sh文件后无输出。</p><h2 id="判断-Shell-是否为登录式"><a href="#判断-Shell-是否为登录式" class="headerlink" title="判断 Shell 是否为登录式"></a>判断 Shell 是否为登录式</h2><p>执行shopt login_shell即可，值为on表示为登录式，off为非登录式</p><p><img src="https://img1.imgtp.com/2023/07/07/GbqTmlVP.png"></p><h2 id="常见的-Shell-启动方式"><a href="#常见的-Shell-启动方式" class="headerlink" title="常见的 Shell 启动方式"></a>常见的 Shell 启动方式</h2><p>通过 Linux 控制台（不是桌面环境自带的终端）或者 ssh 登录 Shell 时（这才是正常登录方式），为交互式的登录 Shell。</p><p>执行 bash 命令时默认是非登录的，增加–login选项（简写为-l）后变成登录式。</p><p>使用由()包围的组命令或者命令替换进入子 Shell 时，子 Shell 会继承父 Shell 的交互和登录属性。此种子进程只是由fork创建，没有执行exce，不会重新加载配置文件</p><p><img src="https://img1.imgtp.com/2023/07/07/jb0Hzb0Z.png"></p><p>ssh 执行远程命令，但不登录时，为非交互非登录式。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jwt</title>
    <link href="/blog/2023/06/12/Jwt/"/>
    <url>/blog/2023/06/12/Jwt/</url>
    
    <content type="html"><![CDATA[<h2 id="JWT的简介"><a href="#JWT的简介" class="headerlink" title="JWT的简介"></a>JWT的简介</h2><h3 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h3><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。<br>流程上是这样的：</p><p>用户使用用户名密码来请求服务器<br>服务器进行验证用户的信息<br>服务器通过验证发送给用户一个token<br>客户端存储token，并在每次请求时附送上这个token值<br>服务端验证token值，并返回数据</p><p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。<br>JWT是由三段信息构成的，将这三段信息文本用.链接一起就构成了Jwt字符串。就像这样:</p><div class="code-wrapper"><pre><code class="hljs gcode">eyJ<span class="hljs-number">0</span>eXAiOiJKV<span class="hljs-number">1</span>QiLCJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiJ9</span>.eyJ<span class="hljs-number">1</span>c<span class="hljs-number">2</span>VybmFtZSI<span class="hljs-number">6</span>I<span class="hljs-symbol">nFhcSIsInJvbGUiOiJhZG1</span>pbiIsImV<span class="hljs-number">4</span>cCI<span class="hljs-number">6</span>MTY<span class="hljs-number">4</span><span class="hljs-symbol">Nzg3</span>MzU<span class="hljs-number">1</span><span class="hljs-symbol">NywianRpIjoiMzk5</span>Mzlm<span class="hljs-symbol">NjktODdmNy00</span>MjcxLWI<span class="hljs-number">0</span>MGMtMzAw<span class="hljs-symbol">NDY2</span>YjI<span class="hljs-number">3</span>Mzc<span class="hljs-number">2</span>I<span class="hljs-symbol">n0</span>.ZdqoypeZ<span class="hljs-number">1</span>-Z<span class="hljs-number">74</span><span class="hljs-symbol">nKUBTH2</span>CBx<span class="hljs-symbol">N494</span>Ck<span class="hljs-symbol">Nrx5</span>SVIq<span class="hljs-number">5</span>D<span class="hljs-name">G3</span>dQ</code></pre></div><p>第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature),彼此之间使用”.”连接。</p><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>jwt的头部承载两部分信息：<br>1.声明类型，这里是jwt<br>2.声明加密的算法 通常直接使用 HMAC SHA256<br>完整的头部就像下面这样的JSON：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  &#x27;typ&#x27;<span class="hljs-punctuation">:</span> &#x27;JWT&#x27;<span class="hljs-punctuation">,</span>  &#x27;alg&#x27;<span class="hljs-punctuation">:</span> &#x27;HS256&#x27;<span class="hljs-punctuation">&#125;</span></code></pre></div><p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分:eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</p><h3 id="playload"><a href="#playload" class="headerlink" title="playload"></a>playload</h3><p>载荷就是存放有效信息的地方。这些有效信息包含三个部分</p><p>1.标准中注册的声明<br>2.公共的声明<br>3.私有的声明</p><p>标准中注册的声明 (建议但不强制使用) ：</p><p>iss: jwt签发者<br>sub: jwt所面向的用户<br>aud: 接收jwt的一方<br>exp: jwt的过期时间，这个过期时间必须要大于签发时间<br>nbf: 定义在什么时间之前，该jwt都是不可用的.<br>iat: jwt的签发时间<br>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。<br>公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.<br>私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。<br>定义一个payload:</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;sub&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1234567890&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xinibb&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h3 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h3><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><p>header (base64后的)<br>payload (base64后的)<br>secret</p><p>这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密(盐自己定义)，然后就构成了jwt的第三部分。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>pom.xml文件引入依赖</p><div class="code-wrapper"><pre><code class="hljs java"> &lt;dependency&gt;            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;            &lt;version&gt;<span class="hljs-number">0.9</span><span class="hljs-number">.1</span>&lt;/version&gt;&lt;/dependency&gt;</code></pre></div><p>定义一个静态方法根据传入的用户名和密码 和上面提到的盐（也就是代码中的<em><strong>sign</strong></em>）生成token</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  String <span class="hljs-title function_">make</span><span class="hljs-params">(String username, String password)</span>&#123;    <span class="hljs-keyword">return</span>    Jwts.builder()              <span class="hljs-comment">//header</span>              .setHeaderParam(<span class="hljs-string">&quot;typ&quot;</span>,<span class="hljs-string">&quot;JWT&quot;</span>)              .setHeaderParam(<span class="hljs-string">&quot;alg&quot;</span>,<span class="hljs-string">&quot;HS256&quot;</span>)                <span class="hljs-comment">//payload</span>              .claim(<span class="hljs-string">&quot;username&quot;</span>,username).claim(<span class="hljs-string">&quot;password&quot;</span>,password)              .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis()+<span class="hljs-number">1000</span>*<span class="hljs-number">15</span>))<span class="hljs-comment">//token过期时间15秒</span>              .setId(UUID.randomUUID().toString())<span class="hljs-comment">//id字段</span>                <span class="hljs-comment">//signatrue</span>              .signWith(SignatureAlgorithm.HS256,sign)<span class="hljs-comment">//设置加密算法以及使用加密的字符sign</span>              .compact();</code></pre></div><p>检查token是否过期</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">chackDate</span><span class="hljs-params">(String token)</span>&#123;<span class="hljs-comment">//检测token是否有效</span>        <span class="hljs-keyword">if</span> (token==<span class="hljs-literal">null</span>||token==<span class="hljs-string">&quot;&quot;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;       <span class="hljs-keyword">try</span> &#123;           Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(sign).parseClaimsJws(token);       &#125;       <span class="hljs-keyword">catch</span> (Exception e)&#123;           e.printStackTrace();           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;       &#125;   <span class="hljs-comment">//无异常说明没过期</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;</code></pre></div><p>解析token</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">checkandparse</span><span class="hljs-params">(String token )</span>&#123;      <span class="hljs-comment">//解析</span>     Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(sign).parseClaimsJws(token);     JwsHeader claimsJwsHeader=claimsJws.getHeader();      System.out.println(claimsJwsHeader.getType());      System.out.println(claimsJwsHeader.getAlgorithm());     <span class="hljs-type">Claims</span> <span class="hljs-variable">claimsJwsBody</span> <span class="hljs-operator">=</span> claimsJws.getBody();      System.out.println(claimsJwsBody.get(<span class="hljs-string">&quot;username&quot;</span>));      System.out.println(claimsJwsBody.get(<span class="hljs-string">&quot;password&quot;</span>));      System.out.println(claimsJwsBody.getId());       System.out.println(claimsJwsBody.getExpiration());      System.out.println(claimsJws.getSignature());   &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ajax</title>
    <link href="/blog/2023/06/09/ajax/"/>
    <url>/blog/2023/06/09/ajax/</url>
    
    <content type="html"><![CDATA[<p>AJAX 代表异步的 JavaScript 和 XML（Asynchronous JavaScript And XML）。简单点说，就是使用 <strong>XMLHttpRequest</strong> 对象与服务器通信。它可以使用 JSON、XML、HTML 和文本文件等格式发送和接收数据。AJAX 最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>首先新建一个XMLHttpRequest对象，设置了XMLHttpRequest 对象的 onreadystatechange 属性由哪一个 JavaScript 函数处理响应。这里是handler()。</p><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> httpRequest = <span class="hljs-keyword">new</span> XMLHttpRequest();httpRequest.onreadystatechange = handler;<span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 在这里处理服务器响应。</span>&#125;</code></pre></div><p>要注意的是，函数名后没有括号和参数，因为这是把一个引用赋值给了函数，而不是真正的调用了它。也可以这样写：</p><div class="code-wrapper"><pre><code class="hljs abnf">httpRequest.onreadystatechange <span class="hljs-operator">=</span> () <span class="hljs-operator">=</span>&gt; &#123;  // 在这里处理服务器响应。&#125;<span class="hljs-comment">;</span></code></pre></div><p>通过调用 HTTP 请求对象的 open() 和 send() 方法发送一个实际的请求</p><div class="code-wrapper"><pre><code class="hljs accesslog">httpRequest.open(<span class="hljs-string">&quot;<span class="hljs-keyword">GET</span>&quot;</span>, <span class="hljs-string">&quot;http://www.example.org/some.file&quot;</span>, true);httpRequest.send();</code></pre></div><p>第一个参数是 HTTP 请求方法——GET，POST，HEAD 以及服务器支持的其他方法,第二个参数是你要发送请求的 URL,第三个参数是可选的，用于设置请求是否是异步的,默认为true。<br>send() 方法的参数可以是任何你想发送给服务器的内容，使用send方法传递参数使用的是POST方法，需要设定Content-Type头信息。</p><div class="code-wrapper"><pre><code class="hljs pf">httpRequest.<span class="hljs-built_in">set</span>RequestHeader(  <span class="hljs-string">&quot;Content-Type&quot;</span>,  <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);</code></pre></div><p>在发送请求时，上文说到的 函数名handler负责处理响应。<br>可以先查看请求的状态httpRequest.readyState的值：<br>0（未初始化）或（请求还未初始化）<br>1（正在加载）或（已建立服务器链接）<br>2（已加载）或（请求已接收）<br>3（交互）或（正在处理请求）<br>4（完成）或（请求已完成并且响应已准备好）<br>再检查 HTTP 响应的响应状态码httpRequest.status的值。通过检查响应码 200 OK 判断 AJAX 调用有没有成功。<br>检查完请求状态和 HTTP 响应码后，就可以使用返回的数据了，有两个方法去访问这些数据：<br>httpRequest.responseText：以文本字符串的方式返回服务器响应。<br>httpRequest.responseXML：以 XMLDocument 对象的形式返回服务器响应。</p><h2 id="JQuery中ajax的使用"><a href="#JQuery中ajax的使用" class="headerlink" title="JQuery中ajax的使用"></a>JQuery中ajax的使用</h2><p>举个例子：</p><div class="code-wrapper"><pre><code class="hljs arcade">$.ajax(&#123;            <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;21json.php&#x27;</span>,            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;get&#x27;</span>,            <span class="hljs-comment">// 设置的是请求参数</span>            data: &#123;                <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,                <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>            &#125;,            <span class="hljs-comment">//也可以$ (“#id”).serialize()作为数据</span>            <span class="hljs-comment">//序列化表单中的数据和文本框等input select等的数据</span>            dataType: <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-comment">// 用于设置响应体的类型 注意 跟 data 参数没关系！！！</span>            success: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;                <span class="hljs-comment">// 一旦设置的 dataType 选项，就不再关心 服务端 响应的 Content-Type 了</span>                <span class="hljs-comment">// 客户端会主观认为服务端返回的就是 JSON 格式的字符串</span>                <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res);            &#125;            ,            <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;                <span class="hljs-comment">// 只有请求不正常（状态码不为200）才会执行</span>                <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>, res);            &#125;,            <span class="hljs-attr">complete</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;                <span class="hljs-comment">// 不管是成功还是失败都是完成，都会执行这个 complete 函数(一般功与失败都需要执行的操作写在这里)</span>                <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;complete&#x27;</span>, res);            &#125;        &#125;);</code></pre></div><p>beforeSend 在发送请求之前调用，并且传入一个XMLHttpRequest作为参数。<br>error 在请求出错时调用。传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象（如果有的话）<br>dataFilter 在请求成功之后调用。传入返回的数据以及”dataType”参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数。<br>success 当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。<br>complete 当请求完成之后调用这个函数，无论成功或失败。传入XMLHttpRequest对象，以及一个包含成功或错误代码的字符串。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker上跑一个Redis</title>
    <link href="/blog/2023/05/31/%E8%AE%A9Redis%E5%9C%A8Docker%E8%B7%91/"/>
    <url>/blog/2023/05/31/%E8%AE%A9Redis%E5%9C%A8Docker%E8%B7%91/</url>
    
    <content type="html"><![CDATA[<p>可以用docker pull redis命令下载最新版本的Redis镜像，也可以用“docker pull redis:标签”命令下载指定版本的Redis，如果不指定，就会用默认的标签latest去下载最新版本的Redis镜像。</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull redis</span></code></pre></div><p>run一个redis容器</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -itd --name myredis -p <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> redis:latest</code></pre></div><p>这里的-it表示在终端交互式操作，d表示在后台运行；通过–name指定该容器的名字；通过-p参数指定容器的6379端口映射到宿主机（即运行Docker的机器）6379端口，这样在容器外部就能以宿主机ip:6379的方式访问Redis服务；最后的redis:latest参数指定根据该镜像启动容器。<br>可以使用下面命令查看容器启动时的日志</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker logs myredis</span></code></pre></div><p><img src="https://img1.imgtp.com/2023/06/02/3dQMrwip.png" alt="日志图片"><br>可以通过如下的exec命令进入Redis容器</p><div class="code-wrapper"><pre><code class="hljs awk">docker exec -it myredis <span class="hljs-regexp">/bin/</span>bash</code></pre></div><p>docker exec表示在运行的容器中执行命令，其中myredis参数表示在哪个容器(容器name)里执行命令。</p><p>再使用命令redis-cli创建一个连接到redis服务器的客户端，客户端能对服务器发送命令请求如 set val 1、get val。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/blog/2023/05/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2023/05/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><img src="https://img1.imgtp.com/2023/05/30/PFfKwPj7.png" alt="单例模式"></p><p>太阳系里只有一个太阳，太阳东升西落，循环往复，不多不少仅此一例。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>即在初始阶段就主动进行实例化，并时刻保持一种渴求状态，无论此单例是否有人使用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> &#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sun</span> <span class="hljs-variable">sun</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sun</span>();<span class="hljs-comment">//自有永有的太阳单例</span><span class="hljs-keyword">private</span> <span class="hljs-title function_">Sun</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//构造方法私有化</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sun <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//阳光普照，方法公开化</span><span class="hljs-keyword">return</span> sun;&#125;</code></pre></div><p>在第3行将<strong>太阳类Sun的构造方法设为private，使其私有化</strong>，如此一来太阳类就被完全封闭了起来，实例化工作完全归属于内部事务，任何外部类都无权干预。既然如此，那么我们就让它自己创建自己。</p><p>代码第2行中“private”关键字确保太阳实例的私有性、不可见性和不可访问性；而“static”关键字确保太阳的静态性，将太阳<strong>放入内存里的静态区，在类加载的时候就初始化了</strong>，它与类同在，也就是说它是与类同时期且早于内存堆中的对象实例化的，该实例在内存中永生，内存垃圾收集器也不会对其进行回收；“final”关键字则确保这个太阳是常量、恒量，它是一颗终极的恒星，<strong>引用一旦被赋值就不能再修改</strong>；最后，“new”关键字初始化太阳类的静态实例，并赋予静态常量sun。</p><p>对外部来说只要调用Sun.getInstance()就可以得到太阳对象了，并且不管谁得到，或是得到几次，得到的都是同一个太阳实例，这样就确保了整个太阳系中恒星太阳的唯一合法性，他人无法伪造。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>让太阳一开始就准备就绪，随时供应免费日光。然而，如果始终没人获取日光，那岂不是白造了太阳，一块内存区域被白白地浪费了？这正类似于商家货品滞销的情况，货架上堆放着商品却没人买，白白浪费空间。因此，商家为了降低风险，规定有些商品必须提前预订，这就是“懒汉式”。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Sun sun;<span class="hljs-comment">//这里不进行实例化</span> <span class="hljs-keyword">private</span> <span class="hljs-title function_">Sun</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//构造方法私有化</span>&#125;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sun <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">if</span> (sun == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//如果无日才造日</span> sun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sun</span>(); &#125; <span class="hljs-keyword">return</span> sun; &#125; &#125;</code></pre></div><p>一开始不对Sun进行实例化并去掉了Final修饰符，第一次调用getInstance()再进行实例化，没有被调用则不用实例化，缺点是第一次调用时花费时间长些，要进行实例化sun。</p><p>这样的程序逻辑看似没问题，但其实在多线程模式下是有缺陷的。试想如果是并发请求的话，程序第6行的判空逻辑就会同时成立，这样就会多次实例化太阳，并且<strong>对sun进行多次赋值（覆盖）操作，这违背了单例的理念</strong>。把请求方法加上synchronized让其同步，如此一来，<strong>某线程调用前必须获取同步锁，调用完后会释放锁给其他线程用，也就是给请求排队，一个接一个按顺序来</strong>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> synchronizsed Sun <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">if</span> (sun == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//如果无日才造日</span>sun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sun</span>();&#125;<span class="hljs-keyword">return</span> sun;&#125;</code></pre></div><p><strong>线程还没进入方法内部便直接加锁排队，会造成线程阻塞，资源与时间被白白浪费。</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> &#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Sun sun; <span class="hljs-keyword">private</span> <span class="hljs-title function_">Sun</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//构造方法私有化</span> &#125; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sun <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">if</span> (sun == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//没有太阳进行排队，让排头兵造，有太阳则阳光普照</span>   <span class="hljs-keyword">synchronized</span>(Sun.class)&#123;<span class="hljs-comment">//排队</span>     <span class="hljs-keyword">if</span> (sun == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//排头兵发现没有太阳，排头兵造了太阳，此时有了太阳，后面的队伍则也不需要造日</span>        sun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sun</span>();      &#125;    &#125;  &#125; <span class="hljs-keyword">return</span> sun; <span class="hljs-comment">//阳光普照</span> &#125; &#125;</code></pre></div><p>关键字volatile对静态变量的修饰则能<strong>保证变量值在各线程访问时的同步性、唯一性。</strong><br>第7行又加上了同步块以防止多个线程同时进入，一共用了2个嵌套的判空逻辑，这就是懒加载模式的“双检锁”：<strong>外层放宽入口</strong>，保证线程并发的高效性；<strong>内层加锁同步</strong>，保证实例化的单次运行。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>相比“懒汉式”，其实在大多数情况下通常会更多地使用“饿汉式”，原因在于这个单例迟早是要被实例化占用内存的，延迟懒加载的意义并不大，加锁解锁反而是一种资源浪费，同步更是会降低CPU的利用率，使用不当的话反而会带来不必要的风险。越简单的包容性越强，而越复杂的反而越容易出错。</p><h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><img src="https://img1.imgtp.com/2023/05/31/jWzZg2AD.png" alt="策略模式"></p><p>策略模式强调的是行为的灵活切换，比如一个类的多个方法有着类似的行为接口，可以将它们抽离出来作为一系列策略类，在运行时灵活对接，变更其算法策略，以适应不同的场景。<br>下面定义一个统一的算法策略接口：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Strategy</span> &#123;<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<span class="hljs-comment">//操作数a，被操作数b</span>&#125;</code></pre></div><p>接着分别定义加法策略、减法策略对应的实现类:</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Addition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<span class="hljs-comment">//加数与被加数作为参数</span><span class="hljs-keyword">return</span> a + b;<span class="hljs-comment">//做加法运算并返回结果</span>&#125; &#125; <span class="hljs-comment">//减法省略······</span></code></pre></div><p>将算法策略注入客户端，使用这一系列算法策略。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<span class="hljs-comment">//包含策略接口的系统环境，对外提供更换策略实现的方法setStrategy()以及执行策略的方法</span> <span class="hljs-keyword">private</span> Strategy strategy;<span class="hljs-comment">//算法策略接口</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStrategy</span><span class="hljs-params">(Strategy strategy)</span> &#123;<span class="hljs-comment">//注入算法策略</span> <span class="hljs-built_in">this</span>.strategy = strategy; &#125; <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<span class="hljs-comment">//其本身并不关心执行的是哪种策略实现。</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.strategy.calculate(a, b);<span class="hljs-comment">//返回具体策略的运算结果</span>&#125; &#125;</code></pre></div><p>在setStrategy()中注入的策略，将在getResult()中被使用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-type">Context</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<span class="hljs-comment">//实例化</span> c.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Addition</span>());<span class="hljs-comment">//注入加法策略实现</span> System.out.println(c.getResult(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<span class="hljs-comment">//输出结果为2</span> c.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Subtraction</span>());<span class="hljs-comment">//再注入减法策略实现</span> System.out.println(c.getResult(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<span class="hljs-comment">// 输出结果为0</span> &#125;</code></pre></div><p>只需注入相应的算法策略即可得到结果。此外，今后若要进行功能扩展，只需要新增兼容策略接口的算法策略类（如乘法、除法等）。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>策略模式让策略与系统环境彻底解耦，通过对算法策略的抽象、拆分，再拼装使系统行为的可塑性得到了增强。策略接口的引入也让各种策略实现彻底解放，最终实现算法分立，即插即用。</p><p>策略模式的运用能让系统的应变能力得到提升，适应随时变化的需求。接口的巧妙运用让一系列的策略可以脱离系统而单独存在，使系统拥有更灵活、更强大的“可插拔”扩展功能。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p><img src="https://img1.imgtp.com/2023/05/31/JMsKx7a6.png" alt="命令模式"><br>命令是一个对象向另一个或多个对象发送的指令信息。命令的发送方负责下达指令，接收方则根据命令触发相应的行为，命令模式能够<strong>将指令信息封装成一个对象</strong>，并将此对象作为参数发送给接收方去行，以使命令的请求方与执行方解耦，双方只通过传递各种命令对象来完成任务。</p><p>从命令执行方（Recelver）开始代码实战。灯泡类一定有这样2个行为：通电灯亮，断电灯灭。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bulb</span> &#123;<span class="hljs-comment">//命令执行方</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;灯亮。&quot;</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;灯灭。&quot;</span>);&#125; &#125;</code></pre></div><p>定义一个命令接口，以确立命令的执行规范。</p><div class="code-wrapper"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<span class="hljs-comment">//命令接口</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<span class="hljs-comment">//执行命令</span>&#125;</code></pre></div><p>实现“开命令”（OnCommand）与“关命令”（OffCommand）两个实现类。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OnCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<span class="hljs-comment">//开灯命令实现</span> <span class="hljs-keyword">private</span> Bulb bulb; <span class="hljs-keyword">public</span> <span class="hljs-title function_">OnCommand</span><span class="hljs-params">(Bulb bulb)</span> &#123; <span class="hljs-built_in">this</span>.bulb = bulb; &#125; <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123; bulb.on();<span class="hljs-comment">// 执行开灯操作</span> &#125;&#125;<span class="hljs-comment">//关灯省略······</span></code></pre></div><p>为灯泡接上一个开关,作为命令请求方(Invoker)，开关用来根据输入的命令控制电源的接通与切断。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Switcher</span> &#123; <span class="hljs-keyword">private</span> Command command;<span class="hljs-comment">// 设置命令</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command command)</span> &#123; <span class="hljs-built_in">this</span>.command = command;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">button</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 执行命令</span> command.execute(); &#125; &#125;</code></pre></div><p>主程序代码：</p><div class="code-wrapper"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-type">Switcher</span> <span class="hljs-variable">switcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Switcher</span>();<span class="hljs-comment">//命令请求方</span><span class="hljs-type">Bulb</span> <span class="hljs-variable">bulb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bulb</span>();<span class="hljs-comment">//命令执行方</span> <span class="hljs-type">Command</span> <span class="hljs-variable">onCommand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OnCommand</span>(bulb);<span class="hljs-comment">//开命令</span>  <span class="hljs-type">Command</span> <span class="hljs-variable">offCommand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OffCommand</span>(bulb);<span class="hljs-comment">//关命令</span> switcher.setCommand(onCommand);<span class="hljs-comment">//绑定开命令</span> switcher.button();<span class="hljs-comment">//执行开命令的具体操作</span> switcher.setCommand(offCommand);<span class="hljs-comment">//绑定关命令</span> switcher.button();<span class="hljs-comment">//执行关命令的具体操作</span> &#125; &#125;</code></pre></div><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>命令模式能使我们在不改变任何现有系统代码的情况下，实现命令功能的无限扩展。命令模式巧妙地利用了命令接口将命令请求方与命令执行方隔离开来，使发号施令者与任务执行者解耦，甚至意识不到对方接口的存在而全靠命令的上传下达。</p><p>任何模式都有优缺点。命令模式可能会导致系统中命令类定义泛滥的问题。命令模式其实与策略模式非常类似，只不过前者较后者多了一层封装，命令接口的统一确立，使系统可以忽略命令执行方接口的多样性与复杂性，将接口对接与业务逻辑交给具体的命令去实现，并且实现命令的无限扩展。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p><img src="https://img1.imgtp.com/2023/06/02/xhv6834h.jpg" alt="观察者模式"></p><p>观察者往往眼观六路，耳听八方，随时监控着被观察对象的一举一动。作为主动方的观察者对象必须与被观察对象建立依赖关系，以获得其最新动态。</p><p>观察者模式可以有任意多个观察者对象同时监听某一个对象。监听某个对象的叫观察者（Observer）。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>; <span class="hljs-comment">//更新方法</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserverImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//更新方法</span>    <span class="hljs-comment">//省略</span>    &#125;&#125;</code></pre></div><p>被监听的对象叫被观察者（Subject） 。被观察者对象在内容或状态发生改变时，会通知所有观察者，使它们能自动更新自己的信息。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-keyword">private</span> List&lt;Observer&gt; obsList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&lt;Observer&gt;();    <span class="hljs-comment">//定义一个观察者数组</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(Oberver obs)</span>       <span class="hljs-comment">//增加一个观察者</span>    &#123;<span class="hljs-built_in">this</span>.obsList.add(obs); &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delObserver</span><span class="hljs-params">(Observer obs)</span><span class="hljs-comment">//删除观察者</span>    &#123;<span class="hljs-built_in">this</span>.obsList.remove(obs);&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">//通知所有观察者</span>    <span class="hljs-keyword">for</span> (Observer obs:<span class="hljs-built_in">this</span>.obsList)&#123;              obs.update();         &#125;     &#125;&#125;</code></pre></div><p>被观察者的具体实现：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubjectImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">//具体的业务</span>        <span class="hljs-comment">/*</span><span class="hljs-comment">        do something</span><span class="hljs-comment">       */</span>       <span class="hljs-built_in">super</span>.notifyObservers();<span class="hljs-comment">//执行obs.update();通知观察者们</span>     &#125;&#125;</code></pre></div><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>观察者模式被大量应用于具有一对多关系对象结构的场景，它支持多个观察者订阅一个目标主题。一旦目标主题的状态发生变化，目标对象便主动进行广播，即刻对所有订阅者（观察者）发布全员消息通知。<br>基于这种一对多的关系网，观察者模式以多态化（泛型化）的方式弱化了目标主题与观察者之间强耦合的依赖关系，标准化它们的消息交互接口，使目标主题（单方）的任何状态更新都能被即刻通过广播的形式通知观察者们（多方）。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装与使用</title>
    <link href="/blog/2023/05/19/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2023/05/19/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h1><h2 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h2><p>列出系统中已安装的docker包：</p><div class="code-wrapper"><pre><code class="hljs 1c">yum list installed <span class="hljs-string">| grep docker</span></code></pre></div><p>卸载已安装的docker包：</p><div class="code-wrapper"><pre><code class="hljs livescript">sudo yum remove docker <span class="hljs-string">\</span>                  docker-client <span class="hljs-string">\</span>                  docker-client-latest <span class="hljs-string">\</span>                  docker-common <span class="hljs-string">\</span>                  docker-latest <span class="hljs-string">\</span>                  docker-latest-logrotate <span class="hljs-string">\</span>                  docker-logrotate <span class="hljs-string">\</span>                  docker-engine</code></pre></div><p>如果系统中没有 Docker，则直接进入下一步。<br>安装软件包（提供实用程序）</p><div class="code-wrapper"><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> -y yum-utils</code></pre></div><p>添加 Docker 的 yum 源：</p><div class="code-wrapper"><pre><code class="hljs awk">sudo yum-config-manager --add-repo https:<span class="hljs-regexp">//mi</span>rrors.cloud.tencent.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/centos/</span>docker-ce.repo</code></pre></div><p>yum 安装 Docker：</p><div class="code-wrapper"><pre><code class="hljs stata">sudo yum install docker-ce docker-ce-<span class="hljs-keyword">cli</span> containerd.io docker-buildx-<span class="hljs-keyword">plugin</span> docker-compose-<span class="hljs-keyword">plugin</span></code></pre></div><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>卸载旧版本<br>在安装 Docker 引擎之前，您必须首先确保任何 将卸载冲突的软件包。<br>发行版维护者在 容易。您必须先卸载这些软件包，然后才能安装官方 Docker 引擎的版本。<br>要卸载的非官方软件包是：<br>docker.io<br>docker-compose<br>docker-doc<br>podman-docker<br>此外，Docker引擎依赖于和.码头工人引擎 将这些依赖项捆绑为一个捆绑包：。如果你有 安装了或以前，卸载它们以避免 与 Docker 引擎捆绑的版本冲突</p><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> pkg <span class="hljs-keyword">in</span> docker.io docker-doc docker-compose podman-docker containerd runc; <span class="hljs-keyword">do</span> sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> <span class="hljs-variable">$pkg</span>; done</code></pre></div><p>更新软件包索引并安装软件包以允许使用 基于 HTTPS 的存储库：</p><div class="code-wrapper"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> updatesudo apt-<span class="hljs-built_in">get</span> install ca-certificates curl gnupg</code></pre></div><p>添加 Docker 的官方 GPG 密钥：</p><div class="code-wrapper"><pre><code class="hljs awk">sudo install -m <span class="hljs-number">0755</span> -d <span class="hljs-regexp">/etc/</span>apt/keyringscurl -fsSL https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/u</span>buntu<span class="hljs-regexp">/gpg | sudo gpg --dearmor -o /</span>etc<span class="hljs-regexp">/apt/</span>keyrings/docker.gpgsudo chmod a+r <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/keyrings/</span>docker.gpg</code></pre></div><p>使用以下命令设置存储库：</p><div class="code-wrapper"><pre><code class="hljs gradle">echo \  <span class="hljs-string">&quot;deb [arch=&quot;</span>$(dpkg --<span class="hljs-keyword">print</span>-architecture)<span class="hljs-string">&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span><span class="hljs-string">  &quot;</span>$(. <span class="hljs-regexp">/etc/</span>os-release &amp;&amp; echo <span class="hljs-string">&quot;$VERSION_CODENAME&quot;</span>)<span class="hljs-string">&quot; stable&quot;</span> | \  sudo tee <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list.d/</span>docker.list &gt; <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span></code></pre></div><p>安装最新版本，请运行：</p><div class="code-wrapper"><pre><code class="hljs stata">sudo apt-get install docker-ce docker-ce-<span class="hljs-keyword">cli</span> containerd.io docker-buildx-<span class="hljs-keyword">plugin</span> docker-compose-<span class="hljs-keyword">plugin</span></code></pre></div><h2 id="验证-Docker-版本以确认安装成功"><a href="#验证-Docker-版本以确认安装成功" class="headerlink" title="验证 Docker 版本以确认安装成功"></a>验证 Docker 版本以确认安装成功</h2><div class="code-wrapper"><pre><code class="hljs applescript">docker <span class="hljs-built_in">version</span></code></pre></div><h2 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h2><p>执行以下命令启动 Docker：</p><div class="code-wrapper"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker</code></pre></div><p>然后将 Docker 设置为开机启动：</p><div class="code-wrapper"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> docker</code></pre></div><p>查看 Docker 运行状态：</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">service docker status</span></code></pre></div><p>如图所示，Docker 正在运行：</p><p><img src="https://img1.imgtp.com/2023/05/29/PByA2O8s.png" alt="运行状态图"></p><h2 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h2><div class="code-wrapper"><pre><code class="hljs awk">mkdir -p <span class="hljs-regexp">/etc/</span>docker</code></pre></div><p>配置 Docker 镜像加速源：</p><div class="code-wrapper"><pre><code class="hljs awk">tee <span class="hljs-regexp">/etc/</span>docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span>&#123;  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://mirror.ccs.tencentyun.com&quot;</span>]&#125;EOF</code></pre></div><p>重启守护进程并重启 Docker：</p><div class="code-wrapper"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl daemon-reload &amp;&amp; <span class="hljs-params">system</span>ctl restart docker</code></pre></div><p>重启完成后，镜像加速即配置成功。</p><h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="运行第一个容器"><a href="#运行第一个容器" class="headerlink" title="运行第一个容器"></a>运行第一个容器</h2><p>用 docker run 命令可以直接拉取镜像并运行一个容器，例如：</p><div class="code-wrapper"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> <span class="hljs-attribute">--name</span>=hello hello-world</code></pre></div><p>这行命令会直接拉取 hello-world 镜像，然后运行一个 hello 容器，可以通过以下命令查看该容器的进程：</p><div class="code-wrapper"><pre><code class="hljs css">docker ps -<span class="hljs-selector-tag">a</span></code></pre></div><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>镜像拉取成功后，根据镜像创建容器：</p><div class="code-wrapper"><pre><code class="hljs awk">docker create --name=calibre-web -p <span class="hljs-number">80</span>:<span class="hljs-number">8083</span> -v <span class="hljs-regexp">/data/</span>calibre-web<span class="hljs-regexp">/library:/</span>library -e WEBLANGUAGE=zh_CN johngong/calibre-web</code></pre></div><p>其中：<br>•docker create 是创建容器的命令<br>•–name&#x3D;calibre-web 表示创建的容器的名称<br>•-p 80:8083 表示该容器将 80 端口映射到 8083 端口<br>•-v &#x2F;data&#x2F;calibre-web&#x2F;librery:&#x2F;libray 表示该容器将 &#x2F;data&#x2F;calibre-web&#x2F;library 目录映射为 &#x2F;library 目录<br>•-e WEBLANGUAGE&#x3D;zh_CN 表示该容器定义了一个变量，变量名是 WEBLANGUAGE，变量值是 zh_CN<br>•johngong&#x2F;calibre-web 是容器的镜像，这里也就是我们前面拉取的镜像<br>与 docker run 不同的是，docker create 创建出来的容器不会直接运行。</p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>使用以下命令启动刚才创建好的容器：</p><div class="code-wrapper"><pre><code class="hljs crmsh">docker <span class="hljs-literal">start</span> calibre-web</code></pre></div><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><p>要停止正在运行的容器有两种方法。一种是 docker stop，例如：</p><div class="code-wrapper"><pre><code class="hljs arduino">docker stop calibre-web</code></pre></div><p>另一种方法是 docker kill，例如：</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> calibre-web</code></pre></div><p>这两种方法的区别在于，docker stop 会给时间让容器保存最后的运行状态，而 docker kill 则会直接关闭容器。</p><h2 id="删除终止状态的容器"><a href="#删除终止状态的容器" class="headerlink" title="删除终止状态的容器"></a>删除终止状态的容器</h2><p>使用 docker rm 命令可以删除指定的容器，例如：</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> hello</code></pre></div><h2 id="删除运行状态的容器"><a href="#删除运行状态的容器" class="headerlink" title="删除运行状态的容器"></a>删除运行状态的容器</h2><p>我们先重新运行 calibre-web 容器： </p><div class="code-wrapper"><pre><code class="hljs crmsh">docker <span class="hljs-literal">start</span> calibre-web</code></pre></div><p>这时候我们用 docker rm 删除该容器：</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> calibre-web</code></pre></div><p>命令行会报错,要删除运行状态的容器，需要带上 -f 选项：</p><div class="code-wrapper"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> calibre<span class="hljs-literal">-web</span></code></pre></div><p>正在运行的 calibre-web 会被强制停止并删除。</p><h2 id="删除指定镜像"><a href="#删除指定镜像" class="headerlink" title="删除指定镜像"></a>删除指定镜像</h2><p>使用 docker rmi 命令可以删除指定的镜像，例如：</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker rmi hello-world</span></code></pre></div><h1 id="制作自己的镜像"><a href="#制作自己的镜像" class="headerlink" title="制作自己的镜像"></a>制作自己的镜像</h1><h2 id="编写-Dockerfile文件"><a href="#编写-Dockerfile文件" class="headerlink" title="编写 Dockerfile文件"></a>编写 Dockerfile文件</h2><div class="code-wrapper"><pre><code class="hljs dockerfile">$ <span class="hljs-keyword">FROM</span> node:<span class="hljs-number">11</span><span class="hljs-keyword">MAINTAINER</span> easydoc.net<span class="hljs-comment"># 复制代码</span><span class="hljs-keyword">ADD</span><span class="language-bash"> . /app</span><span class="hljs-comment"># 设置容器启动后的默认运行目录</span><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><span class="hljs-comment"># 运行命令，安装依赖</span><span class="hljs-comment"># RUN 命令可以有多个，但是可以用 &amp;&amp; 连接多个命令来减少层级。</span><span class="hljs-comment"># 例如 RUN npm install &amp;&amp; cd /app &amp;&amp; mkdir logs</span><span class="hljs-keyword">RUN</span><span class="language-bash"> npm install --registry=https://registry.npm.taobao.org</span><span class="hljs-comment"># CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。</span><span class="hljs-comment"># 如果还需要运行其他命令可以用 &amp;&amp; 连接，也可以写成一个shell脚本去执行。</span><span class="hljs-comment"># 例如 CMD cd /app &amp;&amp; ./start.sh</span><span class="hljs-keyword">CMD</span><span class="language-bash"> node app.js</span></code></pre></div><h2 id="Build-为镜像和运行"><a href="#Build-为镜像和运行" class="headerlink" title="Build 为镜像和运行"></a>Build 为镜像和运行</h2><p>编译 </p><div class="code-wrapper"><pre><code class="hljs mipsasm">$ docker <span class="hljs-keyword">build </span>-t test:<span class="hljs-built_in">v1</span> <span class="hljs-comment">#-t 设置镜像名字和版本号</span></code></pre></div><p>命令参考：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a><br>运行容器</p><div class="code-wrapper"><pre><code class="hljs stata">$ docker <span class="hljs-keyword">run</span> -p 8080:8080 --name <span class="hljs-keyword">test</span>-hello <span class="hljs-keyword">test</span>:v1</code></pre></div><p>-p 映射容器内端口到宿主机<br>–name 容器名字<br>-d 后台运行<br>命令参考文档：<a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></p><h2 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h2><div class="code-wrapper"><pre><code class="hljs bash">$ docker ps <span class="hljs-comment">#查看当前运行中的容器</span>docker images <span class="hljs-comment">#查看镜像列表</span>docker <span class="hljs-built_in">rm</span> container-id <span class="hljs-comment">#删除指定 id 的容器</span>docker stop/start container-id <span class="hljs-comment">#停止/启动指定 id 的容器</span>docker rmi image-id <span class="hljs-comment">#删除指定 id 的镜像</span>docker volume <span class="hljs-built_in">ls</span> <span class="hljs-comment">#查看 volume 列表</span>docker network <span class="hljs-built_in">ls</span> <span class="hljs-comment">#查看网络列表</span>docker <span class="hljs-built_in">exec</span> -it name /bin/bash <span class="hljs-comment">#进入容器name</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
