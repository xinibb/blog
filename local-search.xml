<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/blog/2023/05/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2023/05/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><img src="https://img1.imgtp.com/2023/05/30/PFfKwPj7.png" alt="单例模式"></p><p>太阳系里只有一个太阳，太阳东升西落，循环往复，不多不少仅此一例。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>即在初始阶段就主动进行实例化，并时刻保持一种渴求状态，无论此单例是否有人使用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> &#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sun</span> <span class="hljs-variable">sun</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sun</span>();<span class="hljs-comment">//自有永有的太阳单例</span><span class="hljs-keyword">private</span> <span class="hljs-title function_">Sun</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//构造方法私有化</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sun <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//阳光普照，方法公开化</span><span class="hljs-keyword">return</span> sun;&#125;</code></pre></div><p>在第3行将<strong>太阳类Sun的构造方法设为private，使其私有化</strong>，如此一来太阳类就被完全封闭了起来，实例化工作完全归属于内部事务，任何外部类都无权干预。既然如此，那么我们就让它自己创建自己。</p><p>代码第2行中“private”关键字确保太阳实例的私有性、不可见性和不可访问性；而“static”关键字确保太阳的静态性，将太阳<strong>放入内存里的静态区，在类加载的时候就初始化了</strong>，它与类同在，也就是说它是与类同时期且早于内存堆中的对象实例化的，该实例在内存中永生，内存垃圾收集器也不会对其进行回收；“final”关键字则确保这个太阳是常量、恒量，它是一颗终极的恒星，<strong>引用一旦被赋值就不能再修改</strong>；最后，“new”关键字初始化太阳类的静态实例，并赋予静态常量sun。</p><p>对外部来说只要调用Sun.getInstance()就可以得到太阳对象了，并且不管谁得到，或是得到几次，得到的都是同一个太阳实例，这样就确保了整个太阳系中恒星太阳的唯一合法性，他人无法伪造。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>让太阳一开始就准备就绪，随时供应免费日光。然而，如果始终没人获取日光，那岂不是白造了太阳，一块内存区域被白白地浪费了？这正类似于商家货品滞销的情况，货架上堆放着商品却没人买，白白浪费空间。因此，商家为了降低风险，规定有些商品必须提前预订，这就是“懒汉式”。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Sun sun;<span class="hljs-comment">//这里不进行实例化</span> <span class="hljs-keyword">private</span> <span class="hljs-title function_">Sun</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//构造方法私有化</span>&#125;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sun <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">if</span> (sun == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//如果无日才造日</span> sun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sun</span>(); &#125; <span class="hljs-keyword">return</span> sun; &#125; &#125;</code></pre></div><p>一开始不对Sun进行实例化并去掉了Final修饰符，第一次调用getInstance()再进行实例化，没有被调用则不用实例化，缺点是第一次调用时花费时间长些，要进行实例化sun。</p><p>这样的程序逻辑看似没问题，但其实在多线程模式下是有缺陷的。试想如果是并发请求的话，程序第6行的判空逻辑就会同时成立，这样就会多次实例化太阳，并且<strong>对sun进行多次赋值（覆盖）操作，这违背了单例的理念</strong>。把请求方法加上synchronized让其同步，如此一来，<strong>某线程调用前必须获取同步锁，调用完后会释放锁给其他线程用，也就是给请求排队，一个接一个按顺序来</strong>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> synchronizsed Sun <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">if</span> (sun == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//如果无日才造日</span>sun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sun</span>();&#125;<span class="hljs-keyword">return</span> sun;&#125;</code></pre></div><p><strong>线程还没进入方法内部便直接加锁排队，会造成线程阻塞，资源与时间被白白浪费。</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> &#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Sun sun; <span class="hljs-keyword">private</span> <span class="hljs-title function_">Sun</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//构造方法私有化</span> &#125; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sun <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">if</span> (sun == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//没有太阳进行排队，让排头兵造，有太阳则阳光普照</span>   <span class="hljs-keyword">synchronized</span>(Sun.class)&#123;<span class="hljs-comment">//排队</span>     <span class="hljs-keyword">if</span> (sun == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//排头兵发现没有太阳，排头兵造了太阳，此时有了太阳，后面的队伍则也不需要造日</span>        sun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sun</span>();      &#125;    &#125;  &#125; <span class="hljs-keyword">return</span> sun; <span class="hljs-comment">//阳光普照</span> &#125; &#125;</code></pre></div><p>关键字volatile对静态变量的修饰则能<strong>保证变量值在各线程访问时的同步性、唯一性。</strong><br>第7行又加上了同步块以防止多个线程同时进入，一共用了2个嵌套的判空逻辑，这就是懒加载模式的“双检锁”：<strong>外层放宽入口</strong>，保证线程并发的高效性；<strong>内层加锁同步</strong>，保证实例化的单次运行。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>相比“懒汉式”，其实在大多数情况下通常会更多地使用“饿汉式”，原因在于这个单例迟早是要被实例化占用内存的，延迟懒加载的意义并不大，加锁解锁反而是一种资源浪费，同步更是会降低CPU的利用率，使用不当的话反而会带来不必要的风险。越简单的包容性越强，而越复杂的反而越容易出错。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/blog/2023/05/19/Docker/"/>
    <url>/blog/2023/05/19/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h1><h2 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h2><p>列出系统中已安装的docker包：</p><div class="code-wrapper"><pre><code class="hljs 1c">yum list installed <span class="hljs-string">| grep docker</span></code></pre></div><p>卸载已安装的docker包：</p><div class="code-wrapper"><pre><code class="hljs livescript">sudo yum remove docker <span class="hljs-string">\</span>                  docker-client <span class="hljs-string">\</span>                  docker-client-latest <span class="hljs-string">\</span>                  docker-common <span class="hljs-string">\</span>                  docker-latest <span class="hljs-string">\</span>                  docker-latest-logrotate <span class="hljs-string">\</span>                  docker-logrotate <span class="hljs-string">\</span>                  docker-engine</code></pre></div><p>如果系统中没有 Docker，则直接进入下一步。<br>安装软件包（提供实用程序）</p><div class="code-wrapper"><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> -y yum-utils</code></pre></div><p>添加 Docker 的 yum 源：</p><div class="code-wrapper"><pre><code class="hljs awk">sudo yum-config-manager --add-repo https:<span class="hljs-regexp">//mi</span>rrors.cloud.tencent.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/centos/</span>docker-ce.repo</code></pre></div><p>yum 安装 Docker：</p><div class="code-wrapper"><pre><code class="hljs stata">sudo yum install docker-ce docker-ce-<span class="hljs-keyword">cli</span> containerd.io docker-buildx-<span class="hljs-keyword">plugin</span> docker-compose-<span class="hljs-keyword">plugin</span></code></pre></div><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>卸载旧版本<br>在安装 Docker 引擎之前，您必须首先确保任何 将卸载冲突的软件包。<br>发行版维护者在 容易。您必须先卸载这些软件包，然后才能安装官方 Docker 引擎的版本。<br>要卸载的非官方软件包是：<br>docker.io<br>docker-compose<br>docker-doc<br>podman-docker<br>此外，Docker引擎依赖于和.码头工人引擎 将这些依赖项捆绑为一个捆绑包：。如果你有 安装了或以前，卸载它们以避免 与 Docker 引擎捆绑的版本冲突</p><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> pkg <span class="hljs-keyword">in</span> docker.io docker-doc docker-compose podman-docker containerd runc; <span class="hljs-keyword">do</span> sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> <span class="hljs-variable">$pkg</span>; done</code></pre></div><p>更新软件包索引并安装软件包以允许使用 基于 HTTPS 的存储库：</p><div class="code-wrapper"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> updatesudo apt-<span class="hljs-built_in">get</span> install ca-certificates curl gnupg</code></pre></div><p>添加 Docker 的官方 GPG 密钥：</p><div class="code-wrapper"><pre><code class="hljs awk">sudo install -m <span class="hljs-number">0755</span> -d <span class="hljs-regexp">/etc/</span>apt/keyringscurl -fsSL https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/u</span>buntu<span class="hljs-regexp">/gpg | sudo gpg --dearmor -o /</span>etc<span class="hljs-regexp">/apt/</span>keyrings/docker.gpgsudo chmod a+r <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/keyrings/</span>docker.gpg</code></pre></div><p>使用以下命令设置存储库：</p><div class="code-wrapper"><pre><code class="hljs gradle">echo \  <span class="hljs-string">&quot;deb [arch=&quot;</span>$(dpkg --<span class="hljs-keyword">print</span>-architecture)<span class="hljs-string">&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span><span class="hljs-string">  &quot;</span>$(. <span class="hljs-regexp">/etc/</span>os-release &amp;&amp; echo <span class="hljs-string">&quot;$VERSION_CODENAME&quot;</span>)<span class="hljs-string">&quot; stable&quot;</span> | \  sudo tee <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list.d/</span>docker.list &gt; <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span></code></pre></div><p>安装最新版本，请运行：</p><div class="code-wrapper"><pre><code class="hljs stata">sudo apt-get install docker-ce docker-ce-<span class="hljs-keyword">cli</span> containerd.io docker-buildx-<span class="hljs-keyword">plugin</span> docker-compose-<span class="hljs-keyword">plugin</span></code></pre></div><h2 id="验证-Docker-版本以确认安装成功"><a href="#验证-Docker-版本以确认安装成功" class="headerlink" title="验证 Docker 版本以确认安装成功"></a>验证 Docker 版本以确认安装成功</h2><div class="code-wrapper"><pre><code class="hljs applescript">docker <span class="hljs-built_in">version</span></code></pre></div><h2 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h2><p>执行以下命令启动 Docker：</p><div class="code-wrapper"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker</code></pre></div><p>然后将 Docker 设置为开机启动：</p><div class="code-wrapper"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> docker</code></pre></div><p>查看 Docker 运行状态：</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">service docker status</span></code></pre></div><p>如图所示，Docker 正在运行：</p><p><img src="https://img1.imgtp.com/2023/05/29/PByA2O8s.png" alt="运行状态图"></p><h2 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h2><div class="code-wrapper"><pre><code class="hljs awk">mkdir -p <span class="hljs-regexp">/etc/</span>docker</code></pre></div><p>配置 Docker 镜像加速源：</p><div class="code-wrapper"><pre><code class="hljs awk">tee <span class="hljs-regexp">/etc/</span>docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span>&#123;  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://mirror.ccs.tencentyun.com&quot;</span>]&#125;EOF</code></pre></div><p>重启守护进程并重启 Docker：</p><div class="code-wrapper"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl daemon-reload &amp;&amp; <span class="hljs-params">system</span>ctl restart docker</code></pre></div><p>重启完成后，镜像加速即配置成功。</p><h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="运行第一个容器"><a href="#运行第一个容器" class="headerlink" title="运行第一个容器"></a>运行第一个容器</h2><p>用 docker run 命令可以直接拉取镜像并运行一个容器，例如：</p><div class="code-wrapper"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> <span class="hljs-attribute">--name</span>=hello hello-world</code></pre></div><p>这行命令会直接拉取 hello-world 镜像，然后运行一个 hello 容器，可以通过以下命令查看该容器的进程：</p><div class="code-wrapper"><pre><code class="hljs css">docker ps -<span class="hljs-selector-tag">a</span></code></pre></div><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>镜像拉取成功后，根据镜像创建容器：</p><div class="code-wrapper"><pre><code class="hljs awk">docker create --name=calibre-web -p <span class="hljs-number">80</span>:<span class="hljs-number">8083</span> -v <span class="hljs-regexp">/data/</span>calibre-web<span class="hljs-regexp">/library:/</span>library -e WEBLANGUAGE=zh_CN johngong/calibre-web</code></pre></div><p>其中：<br>•docker create 是创建容器的命令<br>•–name&#x3D;calibre-web 表示创建的容器的名称<br>•-p 80:8083 表示该容器将 80 端口映射到 8083 端口<br>•-v &#x2F;data&#x2F;calibre-web&#x2F;librery:&#x2F;libray 表示该容器将 &#x2F;data&#x2F;calibre-web&#x2F;library 目录映射为 &#x2F;library 目录<br>•-e WEBLANGUAGE&#x3D;zh_CN 表示该容器定义了一个变量，变量名是 WEBLANGUAGE，变量值是 zh_CN<br>•johngong&#x2F;calibre-web 是容器的镜像，这里也就是我们前面拉取的镜像<br>与 docker run 不同的是，docker create 创建出来的容器不会直接运行。</p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>使用以下命令启动刚才创建好的容器：</p><div class="code-wrapper"><pre><code class="hljs crmsh">docker <span class="hljs-literal">start</span> calibre-web</code></pre></div><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><p>要停止正在运行的容器有两种方法。一种是 docker stop，例如：</p><div class="code-wrapper"><pre><code class="hljs arduino">docker stop calibre-web</code></pre></div><p>另一种方法是 docker kill，例如：</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> calibre-web</code></pre></div><p>这两种方法的区别在于，docker stop 会给时间让容器保存最后的运行状态，而 docker kill 则会直接关闭容器。</p><h2 id="删除终止状态的容器"><a href="#删除终止状态的容器" class="headerlink" title="删除终止状态的容器"></a>删除终止状态的容器</h2><p>使用 docker rm 命令可以删除指定的容器，例如：</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> hello</code></pre></div><h2 id="删除运行状态的容器"><a href="#删除运行状态的容器" class="headerlink" title="删除运行状态的容器"></a>删除运行状态的容器</h2><p>我们先重新运行 calibre-web 容器： </p><div class="code-wrapper"><pre><code class="hljs crmsh">docker <span class="hljs-literal">start</span> calibre-web</code></pre></div><p>这时候我们用 docker rm 删除该容器：</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> calibre-web</code></pre></div><p>命令行会报错,要删除运行状态的容器，需要带上 -f 选项：</p><div class="code-wrapper"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> calibre<span class="hljs-literal">-web</span></code></pre></div><p>正在运行的 calibre-web 会被强制停止并删除。</p><h2 id="删除指定镜像"><a href="#删除指定镜像" class="headerlink" title="删除指定镜像"></a>删除指定镜像</h2><p>使用 docker rmi 命令可以删除指定的镜像，例如：</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker rmi hello-world</span></code></pre></div><h1 id="制作自己的镜像"><a href="#制作自己的镜像" class="headerlink" title="制作自己的镜像"></a>制作自己的镜像</h1><h2 id="编写-Dockerfile文件"><a href="#编写-Dockerfile文件" class="headerlink" title="编写 Dockerfile文件"></a>编写 Dockerfile文件</h2><div class="code-wrapper"><pre><code class="hljs dockerfile">$ <span class="hljs-keyword">FROM</span> node:<span class="hljs-number">11</span><span class="hljs-keyword">MAINTAINER</span> easydoc.net<span class="hljs-comment"># 复制代码</span><span class="hljs-keyword">ADD</span><span class="language-bash"> . /app</span><span class="hljs-comment"># 设置容器启动后的默认运行目录</span><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><span class="hljs-comment"># 运行命令，安装依赖</span><span class="hljs-comment"># RUN 命令可以有多个，但是可以用 &amp;&amp; 连接多个命令来减少层级。</span><span class="hljs-comment"># 例如 RUN npm install &amp;&amp; cd /app &amp;&amp; mkdir logs</span><span class="hljs-keyword">RUN</span><span class="language-bash"> npm install --registry=https://registry.npm.taobao.org</span><span class="hljs-comment"># CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。</span><span class="hljs-comment"># 如果还需要运行其他命令可以用 &amp;&amp; 连接，也可以写成一个shell脚本去执行。</span><span class="hljs-comment"># 例如 CMD cd /app &amp;&amp; ./start.sh</span><span class="hljs-keyword">CMD</span><span class="language-bash"> node app.js</span></code></pre></div><h2 id="Build-为镜像和运行"><a href="#Build-为镜像和运行" class="headerlink" title="Build 为镜像和运行"></a>Build 为镜像和运行</h2><p>编译 </p><div class="code-wrapper"><pre><code class="hljs mipsasm">$ docker <span class="hljs-keyword">build </span>-t test:<span class="hljs-built_in">v1</span> <span class="hljs-comment">#-t 设置镜像名字和版本号</span></code></pre></div><p>命令参考：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a><br>运行容器</p><div class="code-wrapper"><pre><code class="hljs stata">$ docker <span class="hljs-keyword">run</span> -p 8080:8080 --name <span class="hljs-keyword">test</span>-hello <span class="hljs-keyword">test</span>:v1</code></pre></div><p>-p 映射容器内端口到宿主机<br>–name 容器名字<br>-d 后台运行<br>命令参考文档：<a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></p><h2 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h2><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span> <span class="hljs-comment">#查看当前运行中的容器</span>docker images <span class="hljs-comment">#查看镜像列表</span>docker <span class="hljs-built_in">rm</span> container<span class="hljs-literal">-id</span> <span class="hljs-comment">#删除指定 id 的容器</span>docker stop/<span class="hljs-built_in">start</span> container<span class="hljs-literal">-id</span> <span class="hljs-comment">#停止/启动指定 id 的容器</span>docker rmi image<span class="hljs-literal">-id</span> <span class="hljs-comment">#删除指定 id 的镜像</span>docker volume <span class="hljs-built_in">ls</span> <span class="hljs-comment">#查看 volume 列表</span>docker network <span class="hljs-built_in">ls</span> <span class="hljs-comment">#查看网络列表</span></code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
